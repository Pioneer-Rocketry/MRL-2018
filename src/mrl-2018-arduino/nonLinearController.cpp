#include "nonLinearController.h"
#include "math.h"

//varibles for calculating V1 
  double nonLinearController::integrator_X_history[2] = {0,0};
  double nonLinearController::diff_X_history[6] = {0,0,0,0,0,0};
  
// varibles for calculating V2
  double nonLinearController::integrator_Y_history[2] = {0,0};
  double nonLinearController::diff_Y_history[6] = {0,0,0,0,0,0};
  
// varibles for calculating V3
  double nonLinearController::integrator_Z_history[2] = {0,0};
  double nonLinearController::diff_Z_1_history[6] = {0,0,0,0,0,0};
  double nonLinearController::diff_Z_2_history[6] = {0,0,0,0,0,0};
  
// current linear states
  double nonLinearController::eta[3];
  
// current B matrix
  double nonLinearController::B_matrix[3];
  
// current A matrix
  double nonLinearController::Ainverse[9];
// controller Gains
  double nonLinearController::k1[4] = {-732.5498, -32.0,-40.0,-46.0};
  double nonLinearController::k2[4] = {-209.9749, -20.0, -40.0,-80.0};
  
double cos_x2;
double sin_x2;
double tan_x2;
double cos_x3;
double sin_x3;

double nonLinearController::differentiator(double x_n, double *xHistory){
  double xDiff_n;
  xDiff_n = ( xHistory[5] - x_n)/16;
  xDiff_n = xDiff_n - xHistory[3] + xHistory[1];
  return xDiff_n;  
}//end function differentiator

double nonLinearController::simpsonIntegrator( double x_n, double t_sample,
                          double *xHistory, double *yHistory){
  double y_n;
  y_n = x_n + 4*xHistory[0] + xHistory[1];
  y_n = (t_sample * y_n)/3;
  y_n = y_n + yHistory[1];
  
// shift and update history of output
  yHistory[1] = yHistory[0];
  yHistory[0] = y_n;
  

}// end function simpsonIntegrator


void nonLinearController::updateHistory( double x_n, double *history, int length ){
  for( int i = length-1; i > 0; i--){
    history[i] = history[i-1];
  }
  history[0];
}// end function updateHistory

void nonLinearController::phiPart(double x2, double x3, double x4, double x5, double x6, double *out1){
  double t2;
  double t3;
  double t5;

  /*     This function was generated by the Symbolic Math Toolbox version 6.2. */
  /*     27-Apr-2018 09:34:45 */
  t2 = cos_x3;
  t3 = sin_x3;
  t5 = t2 * x4 - t3 * x5;
  out1[0] = t5 / cos_x2;
  out1[1] = t2 * x5 + t3 * x4;
  out1[2] = x6 - t5 * tan_x2;
}// end function phiPart


void nonLinearController::Ainv(double v, double x2, double x3, double *x){
  double t2;
  double t3;
  double t4;
  double t5;
  double t6;
  double t7;
  double t8;
  double t9;
  double t10;


  /*     This function was generated by the Symbolic Math Toolbox version 6.2. */
  /*     27-Apr-2018 16:26:17 */
  t2 = 1.0 / (v * v);
  t3 = sin_x2;
  t4 = cos_x2;
  t5 = cos_x3;
  t6 = sin_x3;
  t7 = t4 * t6 * 3.42298445126351E+31;
  t8 = t5 * 2.1393652820396941E+30;
  t9 = t6 * 6.1758156074031739E+29;
  t10 = t2 * 1.4839110691509629;
  x[0] = t2 * (t3 * 5.952073575569408E+15 + t4 * t5 * 9.7118480394059776E+16) *
    4.3181747218863512E-16;
  x[1] = t2 * ((t3 * -6.0559281793151651E+29 + t7) + t4 * t5 *
               9.8813049718450782E+30) * -2.450344563562319E-30;
  x[2] = t2 * ((t3 * 6.0559281793151651E+29 + t7) - t4 * t5 *
               9.8813049718450782E+30) * 2.450344563562319E-30;
  x[3] = t2 * t6 * 41.937456706560617;
  x[4] = t2 * (t8 - t9) * 3.92055130169971E-29;
  x[5] = t2 * (t8 + t9) * -3.92055130169971E-29;
  x[6] = t2 * 2.57020936568324;
  x[7] = t10;
  x[8] = t10;

}// end function Ainv


void nonLinearController::Bmax(double x2, double x3, double x4, double x5, double x6, double *Bx){
  double t2;
  double t3;
  double t4;
  double t5;
  double t6;
  double t7;

  /*     This function was generated by the Symbolic Math Toolbox version 6.2. */
  /*     27-Apr-2018 09:34:45 */
  t2 = cos_x2;
  t3 = cos_x3;
  t4 = sin_x2;
  t5 = sin_x3;
  t6 = tan_x2;
  t7 = t6 * t6;
  Bx[0] = 1.0 / (t2 * t2) * (((((t4 * x4 * x5 * 1.801439850948198E+16 + t2 * t3 *
    x5 * x6 * 1.24756913567531E+14) + t2 * t5 * x4 * x6 * 1.24756913567531E+14)
    - t3 * t4 * t5 * (x4 * x4) * 1.801439850948198E+16) + t3 * t4 * t5 * (x5 *
    x5) * 1.801439850948198E+16) - t3 * t3 * t4 * x4 * x5 *
    3.6028797018963968E+16) * -1.110223024625157E-16;
  Bx[1] = (t3 * x4 - t5 * x5) * ((x6 * 1.24756913567531E+14 - t3 * t6 * x4 *
    9.007199254740992E+15) + t5 * t6 * x5 * 9.007199254740992E+15) *
    1.110223024625157E-16;
  Bx[2] = (t3 * x5 + t5 * x4) * ((((t3 * x4 * -9.007199254740992E+15 + t5 * x5 *
    9.007199254740992E+15) + t6 * x6 * 1.24756913567531E+14) - t3 * t7 * x4 *
    1.801439850948198E+16) + t5 * t7 * x5 * 1.801439850948198E+16) *
    1.110223024625157E-16;
}// end function Bmax



void nonLinearController::controlEffert( double e_X, double e_Y, double e_Z, double w_X,
                           double w_Y, double w_Z, // *assume zero double e_X_SP, double e_Y_SP,
                           double e_Z_SP, double Ts, double velocity, double *con_effert){
                             
  double v1;
  double v2;
  double v3;
  
  double x_n_diff;
  double y_n_diff;
  
  double x_n_intg;
  double y_n_intg;
  
  double sig1;
  double sig2;
  double sig3;
  double sig4;
  double tempSig;
  double z_n_sp_diff;

  double B[3];
  double v_B_difference[3];
  
  
// calculate trig values
  cos_x2 = cos(e_Y);
  sin_x2 = sin(e_Y);
  tan_x2 = tan(e_Y);
  cos_x3 = cos(e_Z);
  sin_x3 = sin(e_Z);
  
// first calculate linearized states
  phiPart(e_Y, e_Z, w_X, w_Y, w_Z, (double *)&eta);

// calculate V1 aka linear subsystem for euler angle about x-axis  
  x_n_diff = differentiator( e_X, (double *)&diff_X_history);
  x_n_intg = simpsonIntegrator( e_X, Ts, (double *)&diff_X_history, (double *)&integrator_X_history);
  updateHistory(e_X, (double *)&diff_X_history, 6);
  
  v1 = e_X*k2[0] + eta[0]*k2[1] + x_n_intg*k2[3] + x_n_diff*k2[3];

// calculate V2 aka linear subsystem for euler angle about y-axis  
  y_n_diff = differentiator(e_Y, (double *)&diff_Y_history);
  y_n_intg = simpsonIntegrator( e_Y, Ts, (double *)&diff_Y_history, (double *)&integrator_Y_history);
  updateHistory( e_X, (double *)&diff_Y_history, 6 );
  
  v2 = e_Y*k2[0] + eta[1]*k2[1] + y_n_intg*k2[2] + y_n_diff*k2[3];
  
// calculate V3 aka linear subsystem for euler angle about z-axis
  
  z_n_sp_diff = differentiator( e_Z, (double *)&diff_Z_1_history); //yref dot
  updateHistory(e_Z, (double *)&diff_Z_1_history,6);
  sig1 = e_Z - e_Z_SP;
  sig2 = eta[2] - z_n_sp_diff;
  tempSig = e_Z - e_Z_SP;
  sig3 = simpsonIntegrator(tempSig, Ts, (double *)&diff_Z_2_history, (double *)&integrator_Z_history);
  sig4 = differentiator(tempSig, (double *)&diff_Z_2_history);
  updateHistory(tempSig, (double *)&diff_Z_2_history, 6);
  
  v3 = sig1*k1[0] + sig2*k1[1] + sig3*k1[2] + sig4*k1[3];

// calculate the B matrix for feedback linearization
  Bmax(e_Y, e_Z, w_X, w_Y, w_Z, (double *)&B);
  
// calculate the A inverse matrix for feedback linearization
  Ainv( velocity, e_Y, e_Z, (double *)&Ainverse );
  
// calculate the differnce of vector B and V  ( V - B )
  v_B_difference[0] = v1 - B[0];
  v_B_difference[1] = v2 - B[1];
  v_B_difference[2] = v3 - B[2];
  
  
// Calculate the matrix multiplication of A x (V-B)
  con_effert[0] = Ainverse[0]*v_B_difference[0] + Ainverse[3]*v_B_difference[1] + Ainverse[6]*v_B_difference[2];
  con_effert[1] = Ainverse[1]*v_B_difference[0] + Ainverse[4]*v_B_difference[1] + Ainverse[7]*v_B_difference[2];
  con_effert[2] = Ainverse[2]*v_B_difference[0] + Ainverse[5]*v_B_difference[1] + Ainverse[8]*v_B_difference[2];


}// end function ControlEffert

